<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏Ñ‡∏¥‡∏î‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á "‡∏™‡∏∏‡∏î‡∏¢‡∏≠‡∏î‡∏ä‡πà‡∏≤‡∏á‡∏õ‡∏∞‡∏õ‡∏≤"</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1100px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .header h1 {
            color: #2d3436;
            font-size: 2.2em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .instructions {
            background: #f1f2f6;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 1.1em;
            line-height: 1.5;
        }
        
        .game-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f1f2f6;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .level-info, .score-info, .timer-info {
            text-align: center;
            font-size: 1.1em;
            color: #2d3436;
            padding: 10px;
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .timer-info {
            font-weight: bold;
            font-size: 1.3em;
        }
        
        .timer-warning {
            color: #e17055;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á ‡πÇ‡∏î‡∏¢‡∏õ‡∏∏‡πà‡∏°‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô */
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .other-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }
        
        button {
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        /* ‡∏õ‡∏∏‡πà‡∏°‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡πâ‡∏≥‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà ‡πÄ‡∏î‡πà‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏¥‡πÄ‡∏®‡∏© */
        #testSystemBtn {
            font-size: 22px;
            padding: 20px 50px;
            background: #0984e3;
            color: #fff;
            border-radius: 12px;
            min-width: 250px;
            width: 70%;
            max-width: 400px;
            text-align: center;
        }
        #testSystemBtn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn-primary {
            background: #0984e3;
            color: white;
        }
        
        .btn-success {
            background: #00b894;
            color: white;
        }
        
        .btn-warning {
            background: #fdcb6e;
            color: #2d3436;
        }
        
        .btn-danger {
            background: #e17055;
            color: white;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .game-area {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
        }
        
        /* ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÉ‡∏´‡∏ç‡πà‡∏Å‡∏ß‡πà‡∏≤‡πÇ‡∏ã‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô */
        .game-board {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            border: 3px solid #74b9ff;
            /* Increase flex ratio and max-width to give the board more space */
            flex: 3;
            max-width: 600px;
        }
        .puzzle-pieces {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            border: 3px solid #74b9ff;
            /* Reduce flex ratio and max-width for the piece palette */
            flex: 0.7;
            max-width: 250px;
        }
        
        .puzzle-pieces h3, .game-board h3 {
            text-align: center;
            margin-bottom: 20px;
            color: #2d3436;
            font-size: 1.4em;
        }
        
        .pieces-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            justify-content: center;
            padding: 20px;
            background: white;
            border-radius: 10px;
            min-height: 360px;
            position: relative;
        }
        
        .board-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 2px;
            background: #a5d8ff;
            padding: 20px;
            border-radius: 10px;
            /* ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏ä‡πà‡∏≠‡∏á + ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô */
            width: 346px;
            height: 346px;
            margin: 0 auto;
            position: relative;
            background-image: 
                linear-gradient(#a5d8ff 1px, transparent 1px),
                linear-gradient(90deg, #a5d8ff 1px, transparent 1px);
            background-size: 58px 58px;
        }
        
        .puzzle-piece {
            width: 50px;
            height: 50px;
            cursor: grab;
            border: 2px solid #ddd;
            border-radius: 8px;
            transition: all 0.3s ease;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            margin: 0 auto;
        }
        
        .puzzle-piece:hover {
            transform: scale(1.05);
            border-color: #0984e3;
            box-shadow: 0 5px 15px rgba(9,132,227,0.3);
        }
        
        .puzzle-piece.dragging {
            opacity: 0.6;
            cursor: grabbing;
        }
        
        .board-cell {
            width: 56px;
            height: 56px;
            border: 2px dashed #bdc3c7;
            border-radius: 8px;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .board-cell.drag-over {
            border-color: #0984e3;
            background: #e8f4f8;
            border-style: solid;
        }
        
        .board-cell.occupied {
            border-style: solid;
            border-color: #6c757d;
            background: white;
        }
        
        .board-cell.correct {
            border-color: #00b894;
            border-width: 3px;
            background: #d1f2eb;
        }
        
        .board-cell.incorrect {
            border-color: #e17055;
            border-width: 3px;
            background: #fab1a0;
        }

        /* Style obstacles so players know they cannot place pipes here */
        /* Style obstacles so that players clearly see they cannot place pipes there. Use a red dashed border and a big X overlay. */
        .board-cell.obstacle {
            background: #fff6f6;
            border: 2px dashed #e74c3c;
            position: relative;
        }
        /* Diagonal cross lines for obstacles */
        .board-cell.obstacle::after,
        .board-cell.obstacle::before {
            content: "";
            position: absolute;
            top: 6px;
            left: 6px;
            right: 6px;
            bottom: 6px;
            border-top: 2px solid #e74c3c;
            border-bottom: 2px solid #e74c3c;
            pointer-events: none;
        }
        .board-cell.obstacle::after {
            transform: rotate(45deg);
        }
        .board-cell.obstacle::before {
            transform: rotate(-45deg);
        }
        
        .piece-in-cell {
            width: 100%;
            height: 100%;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 4px;
            cursor: move;
        }
        
        .water-flow {
            position: absolute;
            background-color: rgba(0, 168, 255, 0.5);
            z-index: 5;
            transition: all 0.5s ease;
        }
        
        .trash-bin {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M25,10 L30,10 L30,20 L70,20 L70,10 L75,10 L75,30 L25,30 Z" fill="%23636e72"/><rect x="30" y="35" width="40" height="60" fill="%23d63031"/><rect x="40" y="45" width="5" height="40" fill="%23ffffff"/><rect x="55" y="45" width="5" height="40" fill="%23ffffff"/></svg>');
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            border: 2px dashed #636e72;
            border-radius: 5px;
        }
        
        .trash-bin.highlight {
            border-color: #d63031;
            background-color: rgba(214, 48, 49, 0.1);
            animation: shake 0.5s infinite;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }
        
        .success-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #00b894, #00cec9);
            color: white;
            padding: 40px 60px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            animation: successPop 0.6s ease-out;
            text-align: center;
            max-width: 500px;
        }
        
        .error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #e17055, #d63031);
            color: white;
            padding: 40px 60px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            animation: successPop 0.6s ease-out;
            text-align: center;
            max-width: 500px;
        }
        
        .final-score-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            color: white;
            padding: 40px 60px;
            border-radius: 20px;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            animation: successPop 0.6s ease-out;
            text-align: center;
            max-width: 600px;
            line-height: 1.5;
        }
        
        .grade {
            font-size: 3em;
            margin: 20px 0;
        }
        
        .grade.A-plus { color: #00b894; }
        .grade.A { color: #0984e3; }
        .grade.B-plus { color: #74b9ff; }
        .grade.B { color: #fdcb6e; }
        .grade.C-plus { color: #fd79a8; }
        .grade.C { color: #e17055; }
        .grade.D { color: #636e72; }
        .grade.F { color: #d63031; }
        
        @keyframes successPop {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.3);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        .message-button {
            margin-top: 20px;
            padding: 15px 30px;
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .message-button:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .developer-info {
            text-align: center;
            margin-top: 25px;
            padding: 15px;
            background: #f1f2f6;
            border-radius: 10px;
            color: #636e72;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .developer-info strong {
            color: #2d3436;
        }

        .solution-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .solution-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 800px;
            width: 90%;
            text-align: center;
        }

        .solution-board {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 2px;
            background: #a5d8ff;
            padding: 20px;
            border-radius: 10px;
            width: 346px;
            height: 346px;
            margin: 20px auto;
            position: relative;
            background-image: 
                linear-gradient(#a5d8ff 1px, transparent 1px),
                linear-gradient(90deg, #a5d8ff 1px, transparent 1px);
            background-size: 58px 58px;
        }

        .solution-cell {
            width: 56px;
            height: 56px;
            border: 2px solid #6c757d;
            border-radius: 8px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .solution-piece {
            width: 100%;
            height: 100%;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 4px;
        }

        .solution-path {
            position: absolute;
            background-color: rgba(0, 255, 0, 0.3);
            z-index: -1;
        }

        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            
            .puzzle-pieces, .game-board {
                width: 100%;
                max-width: none;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .puzzle-piece {
                width: 40px;
                height: 40px;
            }
            
            .board-cell {
                width: 46px;
                height: 46px;
            }
            
            .board-grid {
                width: 300px;
                height: 300px;
            }
            
            .controls button {
                padding: 10px 15px;
                font-size: 16px;
            }

            .solution-board {
                width: 300px;
                height: 300px;
            }

            .solution-cell {
                width: 46px;
                height: 46px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏Ñ‡∏¥‡∏î‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á "‡∏™‡∏∏‡∏î‡∏¢‡∏≠‡∏î‡∏ä‡πà‡∏≤‡∏á‡∏õ‡∏∞‡∏õ‡∏≤"</h1>
        </div>
        
        <div class="instructions">
            <strong>‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô:</strong>
            ‡∏•‡∏≤‡∏Å‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ó‡πà‡∏≠‡∏à‡∏≤‡∏Å‡πÅ‡∏ñ‡∏ö‡∏ó‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤‡∏°‡∏∑‡∏≠‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏ö‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å <em>‡∏ß‡∏≤‡∏•‡πå‡∏ß‡∏ô‡πâ‡∏≥</em> ‡∏ã‡∏∂‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏±‡∏ß‡∏à‡πà‡∏≤‡∏¢‡∏ô‡πâ‡∏≥‡∏Å‡∏•‡∏°‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏ä‡πà‡∏≠‡∏á (‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô) ‡πÑ‡∏õ‡∏¢‡∏±‡∏á <em>‡∏Å‡πä‡∏≠‡∏Å‡∏ô‡πâ‡∏≥</em> ‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á (‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î) ‡πÇ‡∏î‡∏¢‡∏ó‡πà‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏à‡∏∏‡∏î‡∏ô‡∏µ‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡πà‡∏≠‡∏ó‡πà‡∏≠‡∏≠‡∏≠‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á  
            ‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢ X ‡∏Ñ‡∏∑‡∏≠‡∏™‡∏¥‡πà‡∏á‡∏Å‡∏µ‡∏î‡∏Ç‡∏ß‡∏≤‡∏á ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ß‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÑ‡∏î‡πâ ‡πÉ‡∏´‡πâ‡∏´‡∏≤‡∏ó‡∏≤‡∏á‡∏•‡∏±‡∏î‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏™‡∏¥‡πà‡∏á‡∏Å‡∏µ‡∏î‡∏Ç‡∏ß‡∏≤‡∏á‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡∏∞‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ó‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á  
            ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏á‡∏ó‡πà‡∏≠‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° <strong>‚Äú‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡πâ‡∏≥‚Äù</strong> ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏ß‡∏¥‡πà‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏ó‡πà‡∏≠‡∏ô‡πâ‡∏≥‡∏ó‡∏µ‡∏•‡∏∞‡∏ä‡∏¥‡πâ‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÑ‡∏Æ‡πÑ‡∏•‡∏ï‡πå‡∏Å‡∏£‡∏≠‡∏ö‡∏™‡∏µ: ‡∏ñ‡πâ‡∏≤‡∏ï‡πà‡∏≠‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏∞‡∏Ç‡∏∂‡πâ‡∏ô‡∏Å‡∏£‡∏≠‡∏ö‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡πÅ‡∏•‡∏∞‡πÑ‡∏´‡∏•‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á‡∏Å‡πä‡∏≠‡∏Å‡∏ô‡πâ‡∏≥ ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ñ‡∏∂‡∏á‡∏Å‡πä‡∏≠‡∏Å‡∏ô‡πâ‡∏≥‡∏à‡∏∞‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡πÅ‡∏•‡∏∞‡∏õ‡∏∏‡πà‡∏°‡πÑ‡∏õ‡∏î‡πà‡∏≤‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ ‡∏´‡∏≤‡∏Å‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ú‡∏¥‡∏î ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏ö‡∏™‡∏µ‡πÅ‡∏î‡∏á‡πÅ‡∏•‡∏∞‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà
        </div>
        
        <div class="game-stats">
            <div class="level-info">
                <strong>üéØ Level: <span id="currentLevel">1</span>/<span id="totalLevels">10</span></strong><br>
                <span id="levelName">‡∏ö‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà 1</span>
            </div>
            <div class="score-info">
                <strong>üèÜ ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏£‡∏ß‡∏°: <span id="totalScore">0</span></strong><br>
                <small>‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏î‡πà‡∏≤‡∏ô‡∏ô‡∏µ‡πâ: <span id="currentScore">10</span>/10</small>
            </div>
            <div class="timer-info" id="timerDisplay">
                <strong>‚è∞ ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÄ‡∏ß‡∏•‡∏≤</strong><br>
                <span id="timeLeft">05:00</span>
            </div>
        </div>
        
        <div class="controls">
            <!-- ‡∏õ‡∏∏‡πà‡∏°‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡πâ‡∏≥‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà‡∏à‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏õ‡∏∏‡πà‡∏°‡∏≠‡∏∑‡πà‡∏ô ‡πÜ -->
            <button class="btn-primary" id="testSystemBtn" onclick="game.testSystem()" disabled>üíß ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡πâ‡∏≥</button>
            <div class="other-buttons">
                <button class="btn-warning" onclick="game.resetLevel()">üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà</button>
                <button class="btn-danger" onclick="game.resetGame()">üõë ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡∏°‡πà</button>
            </div>
        </div>
        
        <div class="game-area">
            <div class="game-board">
                <h3>üè† ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡∏≤‡∏á‡∏ó‡πà‡∏≠</h3>
                <div class="board-grid" id="boardGrid"></div>
            </div>
            
            <div class="puzzle-pieces">
                <h3>üîß ‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ó‡πà‡∏≠‡∏ô‡πâ‡∏≥</h3>
                <div class="pieces-container" id="piecesContainer">
                    <div class="trash-bin" id="trashBin"></div>
                </div>
            </div>
        </div>
        
        <div class="developer-info">
            <strong>‡∏ú‡∏π‡πâ‡∏û‡∏±‡∏í‡∏ô‡∏≤:</strong> ‡∏ô‡∏≤‡∏¢‡∏ò‡∏ô‡∏¥‡∏ó ‡∏ò‡∏ô‡∏û‡∏±‡∏ï‡∏ô‡∏¥‡∏£‡∏±‡∏ä‡∏Å‡∏∏‡∏•<br>
            <strong>‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á:</strong> ‡∏Ñ‡∏£‡∏π‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢<br>
            <strong>‡∏™‡∏ñ‡∏≤‡∏ô‡∏®‡∏∂‡∏Å‡∏©‡∏≤:</strong> ‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏Å‡∏≤‡∏¨‡∏™‡∏¥‡∏ô‡∏ò‡∏∏‡πå‡∏õ‡∏±‡∏ç‡∏ç‡∏≤‡∏ô‡∏∏‡∏Å‡∏π‡∏• ‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î‡∏Å‡∏≤‡∏¨‡∏™‡∏¥‡∏ô‡∏ò‡∏∏‡πå
        </div>
    </div>

    <script>
        class PlumbingGame {
            constructor() {
                this.currentLevel = 1;
                this.totalLevels = 10;
                this.boardSize = 6;
                this.totalPieces = this.boardSize * this.boardSize;
                this.board = Array(this.totalPieces).fill(null);
                this.totalScore = 0;
                this.currentScore = 10;
                this.timeLeft = 300; // 5 ‡∏ô‡∏≤‡∏ó‡∏µ = 300 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
                this.timer = null;
                this.gameStarted = false;
                this.gameCompleted = false;
                this.canMovePieces = false;
                this.startCell = 0;
                this.endCell = 0;
                this.obstacles = [];
                this.solutions = [
                    // Level 1
                    { 
                        pipes: [
                            null, null, null, null, null, null,
                            null, null, null, null, null, null,
                            null, null, null, null, null, null,
                            null, null, null, null, null, null,
                            null, null, null, null, null, null,
                            null, null, null, null, null, null
                        ],
                        path: [0, 6, 12, 18, 24, 30] // ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏â‡∏•‡∏¢
                    },
                    // Level 2-10 (‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏â‡∏•‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏î‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏ï‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£)
                ];
                
                this.pieceTypes = {
                    'straight-vertical': { 
                        name: '‡∏ó‡πà‡∏≠‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á', 
                        image: this.createStraightVerticalPipeImage(), 
                        connections: ['top', 'bottom'] 
                    },
                    'straight-horizontal': { 
                        name: '‡∏ó‡πà‡∏≠‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô', 
                        image: this.createStraightHorizontalPipeImage(), 
                        connections: ['left', 'right'] 
                    },
                    'left-top': { 
                        name: '‡∏ó‡πà‡∏≠‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏ã‡πâ‡∏≤‡∏¢‡∏ö‡∏ô', 
                        image: this.createLeftTopPipeImage(), 
                        connections: ['top', 'left'] 
                    },
                    'right-top': { 
                        name: '‡∏ó‡πà‡∏≠‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏Ç‡∏ß‡∏≤‡∏ö‡∏ô', 
                        image: this.createRightTopPipeImage(), 
                        connections: ['top', 'right'] 
                    },
                    'left-bottom': { 
                        name: '‡∏ó‡πà‡∏≠‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏ã‡πâ‡∏≤‡∏¢‡∏•‡πà‡∏≤‡∏á', 
                        image: this.createLeftBottomPipeImage(), 
                        connections: ['bottom', 'left'] 
                    },
                    'right-bottom': { 
                        name: '‡∏ó‡πà‡∏≠‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏Ç‡∏ß‡∏≤‡∏•‡πà‡∏≤‡∏á', 
                        image: this.createRightBottomPipeImage(), 
                        connections: ['bottom', 'right'] 
                    }
                };
                
                // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏î‡πà‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏•‡∏¢‡πÑ‡∏î‡πâ‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô
                // ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏î‡πà‡∏≤‡∏ô‡∏°‡∏µ start ‡πÅ‡∏•‡∏∞ end ‡πÄ‡∏õ‡πá‡∏ô‡∏î‡∏±‡∏ä‡∏ô‡∏µ‡∏Ç‡∏≠‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á 6x6 (0-35)
                this.levels = [
                    { name: "‡∏ö‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà 1", obstacles: [], start: 30, end: 5 },   // start: (5,0), end: (0,5)
                    { name: "‡∏ö‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà 2", obstacles: [], start: 29, end: 6 },   // start: (4,5), end: (1,0)
                    { name: "‡∏ö‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà 3", obstacles: [], start: 25, end: 10 },  // start: (4,1), end: (1,4)
                    { name: "‡∏ö‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà 4", obstacles: [], start: 31, end: 11 },  // start: (5,1), end: (1,5)
                    { name: "‡∏ö‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà 5", obstacles: [], start: 24, end: 9 },   // start: (4,0), end: (1,3)
                    { name: "‡∏ö‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà 6", obstacles: [], start: 28, end: 7 },   // start: (4,4), end: (1,1)
                    { name: "‡∏ö‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà 7", obstacles: [], start: 33, end: 15 },  // start: (5,3), end: (2,3)
                    { name: "‡∏ö‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà 8", obstacles: [], start: 32, end: 13 },  // start: (5,2), end: (2,1)
                    { name: "‡∏ö‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà 9", obstacles: [], start: 34, end: 4 },   // start: (5,4), end: (0,4)
                    { name: "‡∏ö‡πâ‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà 10", obstacles: [], start: 26, end: 16 } // start: (4,2), end: (2,4)
                ];
                
                this.init();
            }

            init() {
                this.loadLevel(this.currentLevel);
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.addEventListener('dragstart', this.handleDragStart.bind(this));
                document.addEventListener('dragover', this.handleDragOver.bind(this));
                document.addEventListener('dragleave', this.handleDragLeave.bind(this));
                document.addEventListener('drop', this.handleDrop.bind(this));
                document.addEventListener('dragend', this.handleDragEnd.bind(this));
                
                // Trash bin events
                const trashBin = document.getElementById('trashBin');
                trashBin.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    trashBin.classList.add('highlight');
                });
                
                trashBin.addEventListener('dragleave', () => {
                    trashBin.classList.remove('highlight');
                });
                
                trashBin.addEventListener('drop', (e) => {
                    e.preventDefault();
                    trashBin.classList.remove('highlight');
                    
                    const fromCell = e.dataTransfer.getData('fromCell');
                    if (fromCell) {
                        this.returnPieceToContainer(fromCell);
                    }
                });
            }

            loadLevel(level) {
                if (level < 1 || level > this.totalLevels) return;
                
                this.currentLevel = level;
                this.currentScore = 10;
                this.timeLeft = 300;
                this.board = Array(this.totalPieces).fill(null);
                this.gameStarted = false;
                this.gameCompleted = false;
                this.canMovePieces = false;
                // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏î‡πà‡∏≤‡∏ô‡πÉ‡∏´‡∏°‡πà ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏¥‡πà‡∏á‡∏Å‡∏µ‡∏î‡∏Ç‡∏ß‡∏≤‡∏á‡πÅ‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏ó‡∏±‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏â‡∏•‡∏¢
                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏â‡∏•‡∏¢‡∏Ñ‡∏£‡πà‡∏≤‡∏ß ‡πÜ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡πà‡∏≤‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏á‡∏™‡∏¥‡πà‡∏á‡∏Å‡∏µ‡∏î‡∏Ç‡∏ß‡∏≤‡∏á‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ô‡∏µ‡πâ
                // ‡∏´‡∏≤‡∏Å‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏â‡∏•‡∏¢‡πÉ‡∏ô this.solutions ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡πÇ‡∏î‡∏¢ computeSolution()
                this.computeSolution();
                const solutionPath = this.solutions[this.currentLevel - 1].path || [];
                const available = [];
                for (let i = 0; i < this.totalPieces; i++) {
                    if (i !== this.startCell && i !== this.endCell && !solutionPath.includes(i)) {
                        available.push(i);
                    }
                }
                // ‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏¥‡πà‡∏á‡∏Å‡∏µ‡∏î‡∏Ç‡∏ß‡∏≤‡∏á 1-2 ‡∏à‡∏∏‡∏î (‡πÑ‡∏°‡πà‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ) ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏ó‡∏±‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏â‡∏•‡∏¢
                const obstacles = [];
                const maxObstacles = Math.min(available.length, 2);
                for (let i = 0; i < maxObstacles; i++) {
                    const randIndex = Math.floor(Math.random() * available.length);
                    obstacles.push(available[randIndex]);
                    available.splice(randIndex, 1);
                }
                this.obstacles = obstacles;
                this.levels[level-1].obstacles = obstacles;
                
                // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏£‡∏∞‡∏ö‡∏∏‡πÑ‡∏ß‡πâ‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πà‡∏≤‡∏ô ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
                if (this.levels[level-1].start !== undefined && this.levels[level-1].end !== undefined) {
                    this.startCell = this.levels[level-1].start;
                    this.endCell = this.levels[level-1].end;
                } else {
                    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡∏´‡∏ô‡∏î ‡πÉ‡∏´‡πâ‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÅ‡∏ñ‡∏ß‡∏ö‡∏ô‡∏™‡∏∏‡∏î‡∏´‡∏£‡∏∑‡∏≠‡∏•‡πà‡∏≤‡∏á‡∏™‡∏∏‡∏î
                    do {
                        this.startCell = Math.floor(Math.random() * (this.totalPieces - this.boardSize * 2)) + this.boardSize;
                        this.endCell = Math.floor(Math.random() * (this.totalPieces - this.boardSize * 2)) + this.boardSize;
                    } while (
                        this.startCell === this.endCell || 
                        Math.floor(this.startCell / this.boardSize) === 0 || 
                        Math.floor(this.startCell / this.boardSize) === this.boardSize - 1 ||
                        Math.floor(this.endCell / this.boardSize) === 0 || 
                        Math.floor(this.endCell / this.boardSize) === this.boardSize - 1
                    );
                }
                
                // Place valve at start and faucet at end
                this.board[this.startCell] = 'valve';
                this.board[this.endCell] = 'faucet';
                
                // Update UI
                document.getElementById('currentLevel').textContent = this.currentLevel;
                document.getElementById('levelName').textContent = this.levels[level-1].name;
                document.getElementById('currentScore').textContent = this.currentScore;
                document.getElementById('timeLeft').textContent = '05:00';
                document.getElementById('timerDisplay').classList.remove('timer-warning');
                document.getElementById('testSystemBtn').disabled = true;
                
                // Clear previous timer
                if (this.timer) clearInterval(this.timer);
                
                // Generate game board
                this.generateBoardGrid();
                this.generatePuzzlePieces();

                // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à
                setTimeout(() => {
                    this.showStartPrompt();
                }, 0);
            }

            startGame() {
                if (this.gameStarted) return;

                this.gameStarted = true;
                this.canMovePieces = true;
                // ‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏∏‡πà‡∏°‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡πâ‡∏≥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
                document.getElementById('testSystemBtn').disabled = false;

                // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏±‡∏ö‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á
                this.timer = setInterval(() => {
                    this.timeLeft--;
                    this.updateTimerDisplay();
                    
                    if (this.timeLeft <= 0) {
                        clearInterval(this.timer);
                        this.showErrorMessage('‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πà‡∏ô‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß!');
                        this.canMovePieces = false;
                    }
                }, 1000);
            }

            generateBoardGrid() {
                const boardGrid = document.getElementById('boardGrid');
                boardGrid.innerHTML = '';
                
                // Create cells
                for (let i = 0; i < this.totalPieces; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'board-cell';
                    cell.dataset.index = i;
                    
                    // Add obstacles
                    if (this.obstacles.includes(i)) {
                        cell.classList.add('obstacle');
                        cell.innerHTML = '';
                    }
                    // Add valve (start point)
                    else if (i === this.startCell) {
                        const pieceInCell = document.createElement('div');
                        pieceInCell.className = 'piece-in-cell';
                        pieceInCell.dataset.type = 'valve';
                        pieceInCell.style.backgroundImage = `url(${this.createValveImage()})`;
                        cell.appendChild(pieceInCell);
                        cell.classList.add('occupied');
                        
                        const startPoint = document.createElement('div');
                        startPoint.className = 'start-point';
                        startPoint.textContent = 'Start';
                        pieceInCell.appendChild(startPoint);
                    }
                    // Add faucet (end point)
                    else if (i === this.endCell) {
                        const pieceInCell = document.createElement('div');
                        pieceInCell.className = 'piece-in-cell';
                        pieceInCell.dataset.type = 'faucet';
                        pieceInCell.style.backgroundImage = `url(${this.createFaucetImage()})`;
                        cell.appendChild(pieceInCell);
                        cell.classList.add('occupied');
                        
                        const endPoint = document.createElement('div');
                        endPoint.className = 'end-point';
                        endPoint.textContent = 'End';
                        pieceInCell.appendChild(endPoint);
                    }
                    
                    boardGrid.appendChild(cell);
                }
            }

            generatePuzzlePieces() {
                const piecesContainer = document.getElementById('piecesContainer');
                piecesContainer.innerHTML = '';
                
                // Create pipe pieces
                const pipeTypes = ['straight-vertical', 'straight-horizontal', 'left-top', 'right-top', 'left-bottom', 'right-bottom'];
                for (const type of pipeTypes) {
                    const piece = document.createElement('div');
                    piece.className = 'puzzle-piece';
                    piece.draggable = true;
                    piece.dataset.type = type;
                    piece.style.backgroundImage = `url(${this.pieceTypes[type].image})`;
                    piece.title = this.pieceTypes[type].name;
                    piecesContainer.appendChild(piece);
                }
                
                // Add trash bin
                const trashBin = document.createElement('div');
                trashBin.className = 'trash-bin';
                trashBin.id = 'trashBin';
                piecesContainer.appendChild(trashBin);

                // Attach drag events to the new trash bin so that pieces can always be removed
                trashBin.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    trashBin.classList.add('highlight');
                });
                trashBin.addEventListener('dragleave', () => {
                    trashBin.classList.remove('highlight');
                });
                trashBin.addEventListener('drop', (e) => {
                    e.preventDefault();
                    trashBin.classList.remove('highlight');
                    const fromCell = e.dataTransfer.getData('fromCell');
                    if (fromCell) {
                        this.returnPieceToContainer(fromCell);
                    }
                });
            }

            handleDragStart(e) {
                // Ignore drag start if game not in moveable state
                if (!this.canMovePieces) return;
                // Determine what is being dragged. It could be a palette piece, a piece-in-cell,
                // a board cell containing a piece, or a child element within a piece (like the "Start/End" label).
                let dragTarget = e.target;
                // If the clicked element is inside a placed piece, climb up to the .piece-in-cell element
                const pieceParent = dragTarget.closest('.piece-in-cell');
                if (pieceParent) {
                    dragTarget = pieceParent;
                }
                // If user grabs anywhere on a board cell that contains a piece, treat as dragging that piece
                else if (dragTarget.classList.contains('board-cell') && dragTarget.querySelector('.piece-in-cell')) {
                    dragTarget = dragTarget.querySelector('.piece-in-cell');
                }
                // Only allow dragging of palette pieces or pieces placed on the board
                if (!dragTarget.classList.contains('puzzle-piece') && !dragTarget.classList.contains('piece-in-cell')) {
                    return;
                }
                e.dataTransfer.setData('type', dragTarget.dataset.type);
                // If the dragged element is from the board, record its cell index
                if (dragTarget.classList.contains('piece-in-cell')) {
                    e.dataTransfer.setData('fromCell', dragTarget.parentElement.dataset.index);
                }
                dragTarget.classList.add('dragging');
            }

            handleDragOver(e) {
                if (!this.canMovePieces) return;
                
                if (e.target.classList.contains('board-cell') && !e.target.classList.contains('obstacle')) {
                    e.preventDefault();
                    e.target.classList.add('drag-over');
                }
            }

            handleDragLeave(e) {
                if (e.target.classList.contains('board-cell')) {
                    e.target.classList.remove('drag-over');
                }
            }

            handleDrop(e) {
                if (!this.canMovePieces) return;
                
                let dropTarget = e.target;
                
                // If dropped on piece in cell, use parent (cell) as target
                if (dropTarget.classList.contains('piece-in-cell')) {
                    dropTarget = dropTarget.parentElement;
                }
                
                // If dropped on board cell
                if (dropTarget.classList.contains('board-cell') && !dropTarget.classList.contains('obstacle')) {
                    e.preventDefault();
                    dropTarget.classList.remove('drag-over');
                    
                    const pieceType = e.dataTransfer.getData('type');
                    const fromCell = e.dataTransfer.getData('fromCell');
                    const toCell = dropTarget.dataset.index;
                    
                    // Can't replace valve or faucet
                    if (toCell == this.startCell || toCell == this.endCell) {
                        this.showErrorMessage('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡πÑ‡∏î‡πâ');
                        return;
                    }
                    
                    // If moving from one cell to another
                    if (fromCell) {
                        this.movePieceBetweenCells(fromCell, toCell);
                    } 
                    // If placing new piece from pieces container
                    else {
                        this.placeNewPiece(pieceType, toCell);
                    }
                }
            }

            handleDragEnd(e) {
                // Remove dragging class from all elements
                document.querySelectorAll('.dragging').forEach(el => {
                    el.classList.remove('dragging');
                });
                
                // Remove drag-over class from all cells
                document.querySelectorAll('.drag-over').forEach(el => {
                    el.classList.remove('drag-over');
                });
            }

            movePieceBetweenCells(fromCellIndex, toCellIndex) {
                if (fromCellIndex === toCellIndex) return;
                
                const fromCell = document.querySelector(`.board-cell[data-index="${fromCellIndex}"]`);
                const toCell = document.querySelector(`.board-cell[data-index="${toCellIndex}"]`);
                const piece = fromCell.querySelector('.piece-in-cell');
                
                if (!piece) return;
                
                // If target cell has a piece, move it to original cell
                if (toCell.querySelector('.piece-in-cell')) {
                    const pieceToMove = toCell.querySelector('.piece-in-cell');
                    fromCell.innerHTML = '';
                    fromCell.appendChild(pieceToMove);
                    this.board[fromCellIndex] = this.board[toCellIndex];
                } else {
                    fromCell.innerHTML = '';
                    this.board[fromCellIndex] = null;
                    fromCell.classList.remove('occupied');
                }
                
                // Move piece to target cell
                toCell.innerHTML = '';
                toCell.appendChild(piece);
                this.board[toCellIndex] = piece.dataset.type;
                toCell.classList.add('occupied');
            }

            placeNewPiece(pieceType, cellIndex) {
                const cell = document.querySelector(`.board-cell[data-index="${cellIndex}"]`);
                
                // Can't replace valve or faucet
                if (cellIndex == this.startCell || cellIndex == this.endCell) {
                    this.showErrorMessage('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡πÑ‡∏î‡πâ');
                    return;
                }
                
                // If target cell has a piece, return it to pieces container
                if (cell.querySelector('.piece-in-cell')) {
                    this.returnPieceToContainer(cellIndex);
                }
                
                // Place new piece
                this.board[cellIndex] = pieceType;
                
                const pieceInCell = document.createElement('div');
                pieceInCell.className = 'piece-in-cell';
                pieceInCell.dataset.type = pieceType;
                pieceInCell.style.backgroundImage = `url(${this.pieceTypes[pieceType].image})`;
                pieceInCell.draggable = true;
                
                cell.innerHTML = '';
                cell.appendChild(pieceInCell);
                cell.classList.add('occupied');
            }

            returnPieceToContainer(cellIndex) {
                const cell = document.querySelector(`.board-cell[data-index="${cellIndex}"]`);
                const pieceInCell = cell.querySelector('.piece-in-cell');
                
                if (pieceInCell && cellIndex != this.startCell && cellIndex != this.endCell) {
                    this.board[cellIndex] = null;
                    cell.innerHTML = '';
                    cell.classList.remove('occupied');
                }
            }

            testSystem() {
                // Run the system step by step, highlighting each piece as water flows.
                // Disable piece movement during testing
                if (!this.gameStarted || this.gameCompleted) return;
                this.canMovePieces = false;

                // Clear previous highlights
                document.querySelectorAll('.board-cell').forEach(cell => {
                    cell.classList.remove('incorrect', 'correct');
                });

                let currentCell = this.startCell;
                let fromDirection = null;

                const step = () => {
                    const cellElement = document.querySelector(`.board-cell[data-index="${currentCell}"]`);
                    if (cellElement) {
                        cellElement.classList.add('correct');
                    }
                    const pieceType = this.board[currentCell];
                    // Empty cell (no pipe)
                    if (!pieceType) {
                        if (cellElement) cellElement.classList.add('incorrect');
                        this.showErrorMessage('‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡πà‡∏≠‡∏ô‡πâ‡∏≥‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
                        return;
                    }
                    // End reached
                    if (pieceType === 'faucet') {
                        setTimeout(() => {
                            // Use the improved water flow animation that follows
                            // the actual pipe layout
                            this.showWaterFlowNew();
                        }, 300);
                        return;
                    }
                    let nextDirection = null;
                    if (pieceType === 'valve') {
                        // For the valve, determine which adjacent cell has a pipe
                        const row = Math.floor(currentCell / this.boardSize);
                        const col = currentCell % this.boardSize;
                        const candidates = [];
                        if (row > 0 && this.board[currentCell - this.boardSize]) {
                            candidates.push('top');
                        }
                        if (row < this.boardSize - 1 && this.board[currentCell + this.boardSize]) {
                            candidates.push('bottom');
                        }
                        if (col > 0 && this.board[currentCell - 1]) {
                            candidates.push('left');
                        }
                        if (col < this.boardSize - 1 && this.board[currentCell + 1]) {
                            candidates.push('right');
                        }
                        // Must have exactly one connection from the valve
                        if (candidates.length !== 1) {
                            if (cellElement) cellElement.classList.add('incorrect');
                            this.showErrorMessage('‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡πà‡∏≠‡∏ó‡πà‡∏≠‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏ä‡∏¥‡πâ‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô');
                            return;
                        }
                        nextDirection = candidates[0];
                    } else {
                        // For pipe pieces, validate connections
                        const connections = this.pieceTypes[pieceType].connections;
                        // If no incoming direction defined, deduce one based on adjacent pipes
                        if (fromDirection === null) {
                            const row = Math.floor(currentCell / this.boardSize);
                            const col = currentCell % this.boardSize;
                            const possibleFrom = [];
                            if (row > 0 && this.board[currentCell - this.boardSize]) possibleFrom.push('top');
                            if (row < this.boardSize - 1 && this.board[currentCell + this.boardSize]) possibleFrom.push('bottom');
                            if (col > 0 && this.board[currentCell - 1]) possibleFrom.push('left');
                            if (col < this.boardSize - 1 && this.board[currentCell + 1]) possibleFrom.push('right');
                            for (const dir of possibleFrom) {
                                if (connections.includes(dir)) {
                                    fromDirection = dir;
                                    break;
                                }
                            }
                            if (fromDirection === null) {
                                if (cellElement) cellElement.classList.add('incorrect');
                                this.showErrorMessage('‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡πà‡∏≠‡∏ô‡πâ‡∏≥‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
                                return;
                            }
                        }
                        if (!connections.includes(fromDirection)) {
                            if (cellElement) cellElement.classList.add('incorrect');
                            this.showErrorMessage('‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡πà‡∏≠‡∏ô‡πâ‡∏≥‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
                            return;
                        }
                        const possible = connections.filter(dir => dir !== fromDirection);
                        if (possible.length === 0) {
                            if (cellElement) cellElement.classList.add('incorrect');
                            this.showErrorMessage('‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡πà‡∏≠‡∏ô‡πâ‡∏≥‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
                            return;
                        }
                        nextDirection = possible[0];
                    }
                    // Determine next cell based on direction
                    let nextCell = null;
                    let newFrom = null;
                    const r = Math.floor(currentCell / this.boardSize);
                    const c = currentCell % this.boardSize;
                    switch (nextDirection) {
                        case 'top':
                            if (r === 0) {
                                if (cellElement) cellElement.classList.add('incorrect');
                                this.showErrorMessage('‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡πà‡∏≠‡∏ô‡πâ‡∏≥‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
                                return;
                            }
                            nextCell = currentCell - this.boardSize;
                            newFrom = 'bottom';
                            break;
                        case 'bottom':
                            if (r === this.boardSize - 1) {
                                if (cellElement) cellElement.classList.add('incorrect');
                                this.showErrorMessage('‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡πà‡∏≠‡∏ô‡πâ‡∏≥‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
                                return;
                            }
                            nextCell = currentCell + this.boardSize;
                            newFrom = 'top';
                            break;
                        case 'left':
                            if (c === 0) {
                                if (cellElement) cellElement.classList.add('incorrect');
                                this.showErrorMessage('‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡πà‡∏≠‡∏ô‡πâ‡∏≥‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
                                return;
                            }
                            nextCell = currentCell - 1;
                            newFrom = 'right';
                            break;
                        case 'right':
                            if (c === this.boardSize - 1) {
                                if (cellElement) cellElement.classList.add('incorrect');
                                this.showErrorMessage('‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡πà‡∏≠‡∏ô‡πâ‡∏≥‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
                                return;
                            }
                            nextCell = currentCell + 1;
                            newFrom = 'left';
                            break;
                        default:
                            return;
                    }
                    currentCell = nextCell;
                    fromDirection = newFrom;
                    setTimeout(step, 300);
                };
                step();
            }

            checkPath() {
                const visited = new Set();
                let currentCell = this.startCell;
                let fromDirection = 'top'; // Water comes from top to valve
                const pathCells = [];
                const incorrectCells = [];
                
                while (true) {
                    pathCells.push(currentCell);
                    
                    // Get piece type at current cell
                    const pieceType = this.board[currentCell];
                    if (!pieceType) {
                        incorrectCells.push(currentCell);
                        return { isValid: false, pathCells, incorrectCells }; // Empty cell
                    }
                    
                    // Check if we've reached the faucet
                    if (pieceType === 'faucet') {
                        // Faucet must have connection from top
                        if (fromDirection !== 'top') {
                            incorrectCells.push(currentCell);
                            return { isValid: false, pathCells, incorrectCells };
                        }
                        return { isValid: true, pathCells, incorrectCells: [] };
                    }
                    
                    // Get piece connections
                    let connections;
                    if (pieceType === 'valve') {
                        connections = ['bottom']; // Valve only connects to bottom
                    } else if (pieceType === 'faucet') {
                        connections = []; // Shouldn't reach here
                    } else {
                        connections = this.pieceTypes[pieceType].connections;
                    }
                    
                    // Check if piece has connection from incoming direction
                    if (!connections.includes(fromDirection)) {
                        incorrectCells.push(currentCell);
                        return { isValid: false, pathCells, incorrectCells };
                    }
                    
                    // Determine next direction (exclude incoming direction)
                    const possibleDirections = connections.filter(dir => dir !== fromDirection);
                    if (possibleDirections.length === 0) {
                        incorrectCells.push(currentCell);
                        return { isValid: false, pathCells, incorrectCells }; // Dead end
                    }
                    const nextDirection = possibleDirections[0];
                    
                    // Move to next cell based on direction
                    let nextCell;
                    const row = Math.floor(currentCell / this.boardSize);
                    const col = currentCell % this.boardSize;
                    
                    switch (nextDirection) {
                        case 'top':
                            if (row === 0) {
                                incorrectCells.push(currentCell);
                                return { isValid: false, pathCells, incorrectCells }; // Can't go up from top row
                            }
                            nextCell = currentCell - this.boardSize;
                            fromDirection = 'bottom';
                            break;
                        case 'bottom':
                            if (row === this.boardSize - 1) {
                                incorrectCells.push(currentCell);
                                return { isValid: false, pathCells, incorrectCells }; // Can't go down from bottom row
                            }
                            nextCell = currentCell + this.boardSize;
                            fromDirection = 'top';
                            break;
                        case 'left':
                            if (col === 0) {
                                incorrectCells.push(currentCell);
                                return { isValid: false, pathCells, incorrectCells }; // Can't go left from first column
                            }
                            nextCell = currentCell - 1;
                            fromDirection = 'right';
                            break;
                        case 'right':
                            if (col === this.boardSize - 1) {
                                incorrectCells.push(currentCell);
                                return { isValid: false, pathCells, incorrectCells }; // Can't go right from last column
                            }
                            nextCell = currentCell + 1;
                            fromDirection = 'left';
                            break;
                    }
                    
                    // Check if next cell is occupied and not visited
                    if (!this.board[nextCell] || visited.has(nextCell)) {
                        incorrectCells.push(currentCell);
                        return { isValid: false, pathCells, incorrectCells };
                    }
                    
                    currentCell = nextCell;
                }
            }

            showWaterFlow() {
                this.canMovePieces = false;
                const visited = new Set();
                let currentCell = this.startCell;
                let fromDirection = 'top';
                const flowElements = [];
                const boardGrid = document.getElementById('boardGrid');
                
                const animateFlow = () => {
                    if (currentCell === undefined) {
                        // Animation complete
                        this.levelCompleted();
                        return;
                    }
                    
                    visited.add(currentCell);
                    
                    // Highlight current cell
                    const cellElement = document.querySelector(`.board-cell[data-index="${currentCell}"]`);
                    if (cellElement) {
                        cellElement.classList.add('correct');
                        
                        // Create water flow element
                        const flow = document.createElement('div');
                        flow.className = 'water-flow';
                        
                        // Position flow element based on direction
                        const cellRect = cellElement.getBoundingClientRect();
                        const gridRect = boardGrid.getBoundingClientRect();
                        
                        let left, top, width, height;
                        
                        const pieceType = this.board[currentCell];
                        
                        if (pieceType === 'valve') {
                            // Valve - vertical flow down
                            left = cellRect.left - gridRect.left + cellRect.width / 4;
                            top = cellRect.top - gridRect.top + cellRect.height / 2;
                            width = cellRect.width / 2;
                            height = cellRect.height / 2;
                        }
                        else if (pieceType === 'faucet') {
                            // Faucet - water pouring down
                            left = cellRect.left - gridRect.left + cellRect.width / 4;
                            top = cellRect.top - gridRect.top + cellRect.height / 2;
                            width = cellRect.width / 2;
                            height = cellRect.height / 2;
                            
                            // Add animation for water filling
                            const tankFill = document.createElement('div');
                            tankFill.className = 'water-flow';
                            tankFill.style.left = `${cellRect.left - gridRect.left}px`;
                            tankFill.style.top = `${cellRect.top - gridRect.top + cellRect.height}px`;
                            tankFill.style.width = `${cellRect.width}px`;
                            tankFill.style.height = '0px';
                            tankFill.style.backgroundColor = 'rgba(0, 168, 255, 0.7)';
                            tankFill.style.transition = 'height 2s ease-out';
                            
                            boardGrid.appendChild(tankFill);
                            setTimeout(() => {
                                tankFill.style.height = '50px';
                            }, 100);
                            
                            flowElements.push(tankFill);
                        }
                        else {
                            // Regular pipe pieces
                            const connections = this.pieceTypes[pieceType].connections;
                            
                            if (connections.includes('top') && connections.includes('bottom')) {
                                // Vertical pipe
                                left = cellRect.left - gridRect.left + cellRect.width / 4;
                                top = cellRect.top - gridRect.top;
                                width = cellRect.width / 2;
                                height = cellRect.height;
                            }
                            else if (connections.includes('left') && connections.includes('right')) {
                                // Horizontal pipe
                                left = cellRect.left - gridRect.left;
                                top = cellRect.top - gridRect.top + cellRect.height / 4;
                                width = cellRect.width;
                                height = cellRect.height / 2;
                            }
                            else if (connections.includes('top') && connections.includes('left')) {
                                // Top-left curve
                                left = cellRect.left - gridRect.left;
                                top = cellRect.top - gridRect.top;
                                width = cellRect.width;
                                height = cellRect.height;
                            }
                            else if (connections.includes('top') && connections.includes('right')) {
                                // Top-right curve
                                left = cellRect.left - gridRect.left;
                                top = cellRect.top - gridRect.top;
                                width = cellRect.width;
                                height = cellRect.height;
                            }
                            else if (connections.includes('bottom') && connections.includes('left')) {
                                // Bottom-left curve
                                left = cellRect.left - gridRect.left;
                                top = cellRect.top - gridRect.top;
                                width = cellRect.width;
                                height = cellRect.height;
                            }
                            else if (connections.includes('bottom') && connections.includes('right')) {
                                // Bottom-right curve
                                left = cellRect.left - gridRect.left;
                                top = cellRect.top - gridRect.top;
                                width = cellRect.width;
                                height = cellRect.height;
                            }
                        }
                        
                        if (left !== undefined) {
                            flow.style.left = `${left}px`;
                            flow.style.top = `${top}px`;
                            flow.style.width = `${width}px`;
                            flow.style.height = `${height}px`;
                            
                            boardGrid.appendChild(flow);
                            flowElements.push(flow);
                        }
                    }
                    
                    // Get piece type at current cell
                    const pieceType = this.board[currentCell];
                    if (!pieceType) return;
                    
                    // Check if we've reached the faucet
                    if (pieceType === 'faucet') {
                        // Finish animation
                        setTimeout(() => {
                            flowElements.forEach(el => el.remove());
                            currentCell = undefined;
                            setTimeout(animateFlow, 500);
                        }, 2000);
                        return;
                    }
                    
                    // Get piece connections
                    let connections;
                    if (pieceType === 'valve') {
                        connections = ['bottom'];
                    } else {
                        connections = this.pieceTypes[pieceType].connections;
                    }
                    
                    // Determine next direction (exclude incoming direction)
                    const possibleDirections = connections.filter(dir => dir !== fromDirection);
                    if (possibleDirections.length === 0) return;
                    const nextDirection = possibleDirections[0];
                    
                    // Move to next cell based on direction
                    let nextCell;
                    const row = Math.floor(currentCell / this.boardSize);
                    const col = currentCell % this.boardSize;
                    
                    switch (nextDirection) {
                        case 'top':
                            nextCell = currentCell - this.boardSize;
                            fromDirection = 'bottom';
                            break;
                        case 'bottom':
                            nextCell = currentCell + this.boardSize;
                            fromDirection = 'top';
                            break;
                        case 'left':
                            nextCell = currentCell - 1;
                            fromDirection = 'right';
                            break;
                        case 'right':
                            nextCell = currentCell + 1;
                            fromDirection = 'left';
                            break;
                    }
                    
                    currentCell = nextCell;
                    setTimeout(animateFlow, 500);
                };
                
                animateFlow();
            }

            /**
             * New water flow animation that determines the path dynamically based
             * on adjacent pieces. This allows water to flow from the valve in
             * any direction and properly traverses curved pipes. Each cell
             * visited along the path is highlighted and a translucent overlay
             * simulates the flow of water. When the faucet is reached the
             * level is marked complete.
             */
            showWaterFlowNew() {
                // Disallow moving pieces during the animation
                this.canMovePieces = false;
                const visited = new Set();
                let currentCell = this.startCell;
                let fromDirection = null;
                const flowElements = [];
                const boardGrid = document.getElementById('boardGrid');
                const opposite = { top: 'bottom', bottom: 'top', left: 'right', right: 'left' };

                // Determine the initial incoming direction by finding the single
                // adjacent pipe connected to the valve. The direction we find
                // here is the incoming direction to the next cell, not the
                // direction of travel from the valve itself.
                const findInitialIncoming = () => {
                    const dirs = ['top', 'bottom', 'left', 'right'];
                    const row = Math.floor(this.startCell / this.boardSize);
                    const col = this.startCell % this.boardSize;
                    for (const dir of dirs) {
                        let adjIdx;
                        switch (dir) {
                            case 'top':
                                if (row > 0) adjIdx = this.startCell - this.boardSize;
                                break;
                            case 'bottom':
                                if (row < this.boardSize - 1) adjIdx = this.startCell + this.boardSize;
                                break;
                            case 'left':
                                if (col > 0) adjIdx = this.startCell - 1;
                                break;
                            case 'right':
                                if (col < this.boardSize - 1) adjIdx = this.startCell + 1;
                                break;
                        }
                        if (adjIdx !== undefined && this.board[adjIdx]) {
                            return opposite[dir];
                        }
                    }
                    return null;
                };
                fromDirection = findInitialIncoming();

                // Helper: compute the next cell to travel to and what the incoming
                // direction should be for that next cell, based on the current
                // piece connections and the board layout.
                const nextStep = (cellIdx, incomingDir) => {
                    const row = Math.floor(cellIdx / this.boardSize);
                    const col = cellIdx % this.boardSize;
                    const pType = this.board[cellIdx];
                    let connections = [];
                    if (pType === 'valve' || pType === 'faucet') {
                        connections = ['top', 'bottom', 'left', 'right'];
                    } else if (this.pieceTypes[pType]) {
                        connections = this.pieceTypes[pType].connections;
                    }
                    // Exclude the direction we came from
                    const dirs = connections.filter(dir => dir !== incomingDir);
                    for (const dir of dirs) {
                        let nextIdx;
                        switch (dir) {
                            case 'top':
                                if (row === 0) continue;
                                nextIdx = cellIdx - this.boardSize;
                                break;
                            case 'bottom':
                                if (row === this.boardSize - 1) continue;
                                nextIdx = cellIdx + this.boardSize;
                                break;
                            case 'left':
                                if (col === 0) continue;
                                nextIdx = cellIdx - 1;
                                break;
                            case 'right':
                                if (col === this.boardSize - 1) continue;
                                nextIdx = cellIdx + 1;
                                break;
                        }
                        if (this.board[nextIdx]) {
                            return { nextCell: nextIdx, nextIncoming: opposite[dir] };
                        }
                    }
                    return { nextCell: undefined, nextIncoming: null };
                };

                const animateFlow = () => {
                    if (currentCell === undefined) {
                        // End of animation
                        this.levelCompleted();
                        return;
                    }
                    visited.add(currentCell);
                    const cellElement = document.querySelector(`.board-cell[data-index="${currentCell}"]`);
                    if (cellElement) {
                        cellElement.classList.add('correct');
                        // Draw a translucent overlay representing water in this cell
                        const flow = document.createElement('div');
                        flow.className = 'water-flow';
                        const cellRect = cellElement.getBoundingClientRect();
                        const gridRect = boardGrid.getBoundingClientRect();
                        let left, top, width, height;
                        const pType = this.board[currentCell];
                        if (pType === 'valve' || pType === 'faucet') {
                            left = cellRect.left - gridRect.left + cellRect.width / 4;
                            top = cellRect.top - gridRect.top + cellRect.height / 4;
                            width = cellRect.width / 2;
                            height = cellRect.height / 2;
                        } else {
                            const conns = this.pieceTypes[pType].connections;
                            if (conns.includes('top') && conns.includes('bottom')) {
                                left = cellRect.left - gridRect.left + cellRect.width / 4;
                                top = cellRect.top - gridRect.top;
                                width = cellRect.width / 2;
                                height = cellRect.height;
                            } else if (conns.includes('left') && conns.includes('right')) {
                                left = cellRect.left - gridRect.left;
                                top = cellRect.top - gridRect.top + cellRect.height / 4;
                                width = cellRect.width;
                                height = cellRect.height / 2;
                            } else {
                                left = cellRect.left - gridRect.left;
                                top = cellRect.top - gridRect.top;
                                width = cellRect.width;
                                height = cellRect.height;
                            }
                        }
                        if (left !== undefined) {
                            flow.style.left = `${left}px`;
                            flow.style.top = `${top}px`;
                            flow.style.width = `${width}px`;
                            flow.style.height = `${height}px`;
                            boardGrid.appendChild(flow);
                            flowElements.push(flow);
                        }
                    }
                    const pType2 = this.board[currentCell];
                    if (!pType2) {
                        currentCell = undefined;
                        setTimeout(animateFlow, 500);
                        return;
                    }
                    if (pType2 === 'faucet') {
                        // Brief pause then finish when water reaches the faucet
                        setTimeout(() => {
                            flowElements.forEach(el => el.remove());
                            currentCell = undefined;
                            setTimeout(animateFlow, 500);
                        }, 800);
                        return;
                    }
                    const { nextCell, nextIncoming } = nextStep(currentCell, fromDirection);
                    if (nextCell === undefined) {
                        currentCell = undefined;
                        setTimeout(animateFlow, 500);
                        return;
                    }
                    currentCell = nextCell;
                    fromDirection = nextIncoming;
                    setTimeout(animateFlow, 500);
                };
                animateFlow();
            }

            /**
             * Compute a simple solution path for the current level. The path
             * always moves vertically from the start cell towards the end row
             * first, then horizontally towards the end column. Appropriate
             * pipe types are placed in each intermediate cell along the path.
             * The resulting pipes and path arrays are stored in
             * this.solutions for the current level so that showSolution() can
             * display a coherent answer. If a solution already exists, it
             * will be overwritten.
             */
            computeSolution() {
                const pipes = Array(this.totalPieces).fill(null);
                const path = [];
                const startRow = Math.floor(this.startCell / this.boardSize);
                const startCol = this.startCell % this.boardSize;
                const endRow = Math.floor(this.endCell / this.boardSize);
                const endCol = this.endCell % this.boardSize;

                // Determine movement directions
                const vDir = endRow > startRow ? 1 : (endRow < startRow ? -1 : 0);
                const hDir = endCol > startCol ? 1 : (endCol < startCol ? -1 : 0);

                let row = startRow;
                let col = startCol;
                // Always include the start cell
                path.push(this.startCell);

                // Move vertically until reaching the same row as the end
                while (row !== endRow) {
                    row += vDir;
                    const idx = row * this.boardSize + col;
                    path.push(idx);
                    // If not the intersection row, place a vertical pipe
                    if (row !== endRow) {
                        pipes[idx] = 'straight-vertical';
                    }
                }

                // At the intersection (same row as end). If horizontal movement is needed
                if (hDir !== 0 && startRow !== endRow) {
                    let cornerPiece = null;
                    if (vDir === -1 && hDir === 1) {
                        cornerPiece = 'right-bottom';
                    } else if (vDir === -1 && hDir === -1) {
                        cornerPiece = 'left-bottom';
                    } else if (vDir === 1 && hDir === 1) {
                        cornerPiece = 'right-top';
                    } else if (vDir === 1 && hDir === -1) {
                        cornerPiece = 'left-top';
                    }
                    const cornerIdx = row * this.boardSize + col;
                    pipes[cornerIdx] = cornerPiece;
                }

                // Move horizontally towards the end column
                while (col !== endCol) {
                    col += hDir;
                    const idx = row * this.boardSize + col;
                    path.push(idx);
                    // Place horizontal pipe if not at end cell
                    if (idx !== this.endCell) {
                        pipes[idx] = 'straight-horizontal';
                    }
                }

                // Store result
                this.solutions[this.currentLevel - 1] = { pipes, path };
            }

            /**
             * Display an overlay prompting the player to start the level. When
             * the player clicks the button, the game timer will start and
             * the overlay will be removed. This function is called after
             * loading or resetting a level to ensure the user explicitly
             * begins play.
             */
            showStartPrompt() {
                // Prevent multiple prompts
                if (document.querySelector('.success-message')) return;
                const message = document.createElement('div');
                message.className = 'success-message';
                message.innerHTML = `
                    <div>‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏•‡πà‡∏ô Level ${this.currentLevel}</div>
                    <div>${this.levels[this.currentLevel-1].name}</div>
                    <div class="message-button" onclick="game.startGame(); game.removeMessages();">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°</div>
                `;
                document.body.appendChild(message);
            }

            levelCompleted() {
                clearInterval(this.timer);
                this.gameCompleted = true;
                
                // Add current score to total score
                this.totalScore += this.currentScore;
                document.getElementById('totalScore').textContent = this.totalScore;
                
                if (this.currentLevel === this.totalLevels) {
                    this.showFinalScore();
                } else {
                    this.showSuccessMessage();
                }
            }

            showSuccessMessage() {
                const message = document.createElement('div');
                message.className = 'success-message';
                // Display a friendly success message and button to proceed to the next level
                message.innerHTML = `
                    <div>‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡πâ‡∏≥‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á</div>
                    <div>‡∏Ñ‡∏∏‡∏ì‡∏ú‡πà‡∏≤‡∏ô Level ${this.currentLevel}</div>
                    <div class="message-button" onclick="game.nextLevel()">‡πÑ‡∏õ Level ${this.currentLevel + 1}</div>
                `;
                document.body.appendChild(message);
            }

            showErrorMessage(text) {
                const message = document.createElement('div');
                message.className = 'error-message';
                message.innerHTML = `
                    <div>${text}</div>
                    <div class="message-button" onclick="game.removeMessages()">‡∏ï‡∏Å‡∏•‡∏á</div>
                `;
                document.body.appendChild(message);
            }

            showFinalScore() {
                const percentage = (this.totalScore / (this.totalLevels * 10)) * 100;
                let grade = 'F';
                
                if (percentage >= 95) grade = 'A+';
                else if (percentage >= 90) grade = 'A';
                else if (percentage >= 85) grade = 'B+';
                else if (percentage >= 80) grade = 'B';
                else if (percentage >= 75) grade = 'C+';
                else if (percentage >= 70) grade = 'C';
                else if (percentage >= 60) grade = 'D';
                
                const message = document.createElement('div');
                message.className = 'final-score-message';
                message.innerHTML = `
                    <div>‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏î‡πâ‡∏ß‡∏¢! ‡∏Ñ‡∏∏‡∏ì‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏Å‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß</div>
                    <div>‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏£‡∏ß‡∏°: ${this.totalScore} / ${this.totalLevels * 10}</div>
                    <div class="grade ${grade}">${grade}</div>
                    <div class="message-button" onclick="game.goToFirstLevel()">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</div>
                `;
                document.body.appendChild(message);
            }

            showSolution() {
                // ‡∏´‡∏≤‡∏Å‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏â‡∏•‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡πà‡∏≤‡∏ô‡∏ô‡∏µ‡πâ ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢ computeSolution()
                if (!this.solutions[this.currentLevel - 1] || !this.solutions[this.currentLevel - 1].pipes) {
                    this.computeSolution();
                }
                const overlay = document.createElement('div');
                overlay.className = 'solution-overlay';
                
                const content = document.createElement('div');
                content.className = 'solution-content';
                
                const solutionBoard = document.createElement('div');
                solutionBoard.className = 'solution-board';
                
                // Create solution cells
                for (let i = 0; i < this.totalPieces; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'solution-cell';
                    
                    // Add valve (start point)
                    if (i === this.startCell) {
                        const piece = document.createElement('div');
                        piece.className = 'solution-piece';
                        piece.style.backgroundImage = `url(${this.createValveImage()})`;
                        cell.appendChild(piece);
                        
                        const startPoint = document.createElement('div');
                        startPoint.className = 'start-point';
                        startPoint.textContent = 'Start';
                        piece.appendChild(startPoint);
                    }
                    // Add faucet (end point)
                    else if (i === this.endCell) {
                        const piece = document.createElement('div');
                        piece.className = 'solution-piece';
                        piece.style.backgroundImage = `url(${this.createFaucetImage()})`;
                        cell.appendChild(piece);
                        
                        const endPoint = document.createElement('div');
                        endPoint.className = 'end-point';
                        endPoint.textContent = 'End';
                        piece.appendChild(endPoint);
                    }
                    // Add solution pipes (if any)
                    else if (this.solutions[this.currentLevel-1]?.pipes[i]) {
                        const pieceType = this.solutions[this.currentLevel-1].pipes[i];
                        const piece = document.createElement('div');
                        piece.className = 'solution-piece';
                        piece.style.backgroundImage = `url(${this.pieceTypes[pieceType].image})`;
                        cell.appendChild(piece);
                    }
                    
                    solutionBoard.appendChild(cell);
                }
                
                // Add solution path visualization
                const solutionPath = this.solutions[this.currentLevel-1]?.path || [];
                solutionPath.forEach(index => {
                    const cell = solutionBoard.children[index];
                    if (cell) {
                        const pathIndicator = document.createElement('div');
                        pathIndicator.className = 'solution-path';
                        cell.appendChild(pathIndicator);
                    }
                });
                
                content.innerHTML = `
                    <h2>‡πÄ‡∏â‡∏•‡∏¢ Level ${this.currentLevel}</h2>
                    <div>${this.levels[this.currentLevel-1].name}</div>
                `;
                content.appendChild(solutionBoard);
                
                const closeButton = document.createElement('button');
                closeButton.className = 'btn-primary';
                closeButton.textContent = '‡∏õ‡∏¥‡∏î';
                closeButton.onclick = () => overlay.remove();
                content.appendChild(closeButton);
                
                overlay.appendChild(content);
                document.body.appendChild(overlay);
            }

            nextLevel() {
                this.removeMessages();
                this.loadLevel(this.currentLevel + 1);
            }

            resetLevel() {
                // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° overlay ‡πÅ‡∏•‡∏∞‡∏´‡∏¢‡∏∏‡∏î‡∏ï‡∏±‡∏ß‡∏à‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏î‡∏¥‡∏°
                this.removeMessages();
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
                // ‡∏£‡∏µ‡πÄ‡∏ã‡∏ï‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡πÇ‡∏î‡∏¢‡πÄ‡∏Å‡πá‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ß‡∏≤‡∏ß‡∏ô‡πâ‡∏≥‡πÅ‡∏•‡∏∞‡∏Å‡πá‡∏≠‡∏Å‡∏ô‡πâ‡∏≥‡πÄ‡∏î‡∏¥‡∏°
                this.board = Array(this.totalPieces).fill(null);
                this.board[this.startCell] = 'valve';
                this.board[this.endCell] = 'faucet';
                this.currentScore = 10;
                this.timeLeft = 300;
                this.gameStarted = false;
                this.gameCompleted = false;
                this.canMovePieces = false;

                // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡πÅ‡∏•‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô UI
                document.getElementById('currentScore').textContent = this.currentScore;
                document.getElementById('timeLeft').textContent = '05:00';
                document.getElementById('timerDisplay').classList.remove('timer-warning');
                document.getElementById('testSystemBtn').disabled = true;

                // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡πÉ‡∏´‡∏°‡πà ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ñ‡∏±‡∏á‡∏Ç‡∏¢‡∏∞‡πÅ‡∏•‡∏∞‡∏î‡∏£‡∏≤‡∏Å‡∏Å‡∏•‡πÑ‡∏Å‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
                this.generateBoardGrid();
                this.generatePuzzlePieces();

                // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà ‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
                setTimeout(() => {
                    this.showStartPrompt();
                }, 0);
            }

            goToFirstLevel() {
                this.removeMessages();
                this.totalScore = 0;
                document.getElementById('totalScore').textContent = this.totalScore;
                this.loadLevel(1);
            }

            resetGame() {
                this.removeMessages();
                this.totalScore = 0;
                this.loadLevel(1);
            }

            removeMessages() {
                // Remove any overlay messages from the DOM
                document.querySelectorAll('.success-message, .error-message, .final-score-message, .solution-overlay').forEach(msg => msg.remove());
                // Re‚Äëenable piece movement if the game has not been completed. Without
                // this, pieces would remain immovable after an error test or message.
                if (!this.gameCompleted) {
                    this.canMovePieces = true;
                }
            }

            updateTimerDisplay() {
                const minutes = Math.floor(this.timeLeft / 60);
                const seconds = this.timeLeft % 60;
                const timerDisplay = document.getElementById('timeLeft');
                
                timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Add warning class when time is low
                const timerInfo = document.getElementById('timerDisplay');
                if (this.timeLeft <= 60) {
                    timerInfo.classList.add('timer-warning');
                } else {
                    timerInfo.classList.remove('timer-warning');
                }
            }

            // Image creation methods for pipe pieces
            createValveImage() {
                /*
                 * Draw a standalone valve with a central body and four blue stubs
                 * indicating that pipes may connect from any direction. The handle
                 * is drawn at the top of the valve body. No built‚Äëin pipe is
                 * included so that the player must place pipes around the valve.
                 */
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');

                // Draw blue stubs for connections
                ctx.fillStyle = '#0984e3';
                // Top stub
                ctx.fillRect(48, 0, 4, 30);
                // Bottom stub
                ctx.fillRect(48, 70, 4, 30);
                // Left stub
                ctx.fillRect(0, 48, 30, 4);
                // Right stub
                ctx.fillRect(70, 48, 30, 4);

                // Valve body (grey circle)
                ctx.fillStyle = '#6c757d';
                ctx.beginPath();
                ctx.arc(50, 50, 18, 0, Math.PI * 2);
                ctx.fill();

                // Valve handle (golden handle at the top)
                ctx.fillStyle = '#fdcb6e';
                // Stem of handle
                ctx.fillRect(47, 20, 6, 18);
                // Handle knob
                ctx.beginPath();
                ctx.arc(50, 20, 6, 0, Math.PI * 2);
                ctx.fill();
                
                return canvas.toDataURL();
            }

            createFaucetImage() {
                /*
                 * Draw a faucet head similar to the valve: a central body with
                 * blue connection stubs on all four sides. This removes the
                 * built‚Äëin pipe so that pipes may connect from any direction.
                 */
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');

                // Blue stubs for pipe connections (use faucet colour #00b894)
                ctx.fillStyle = '#00b894';
                // Top stub
                ctx.fillRect(48, 0, 4, 30);
                // Bottom stub
                ctx.fillRect(48, 70, 4, 30);
                // Left stub
                ctx.fillRect(0, 48, 30, 4);
                // Right stub
                ctx.fillRect(70, 48, 30, 4);

                // Faucet body (grey circle)
                ctx.fillStyle = '#6c757d';
                ctx.beginPath();
                ctx.arc(50, 50, 18, 0, Math.PI * 2);
                ctx.fill();

                // Handle (golden) on top of the body
                ctx.fillStyle = '#fdcb6e';
                ctx.fillRect(47, 20, 6, 18);
                ctx.beginPath();
                ctx.arc(50, 20, 6, 0, Math.PI * 2);
                ctx.fill();

                return canvas.toDataURL();
            }

            createStraightVerticalPipeImage() {
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#0984e3';
                ctx.fillRect(45, 0, 10, 100);
                
                // Pipe connections
                ctx.fillRect(40, 0, 20, 10);
                ctx.fillRect(40, 90, 20, 10);
                
                return canvas.toDataURL();
            }

            createStraightHorizontalPipeImage() {
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#0984e3';
                ctx.fillRect(0, 45, 100, 10);
                
                // Pipe connections
                ctx.fillRect(0, 40, 10, 20);
                ctx.fillRect(90, 40, 10, 20);
                
                return canvas.toDataURL();
            }

            createLeftTopPipeImage() {
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#0984e3';
                // Vertical part
                ctx.fillRect(45, 0, 10, 55);
                // Horizontal part
                ctx.fillRect(0, 45, 55, 10);
                // Curve
                ctx.beginPath();
                ctx.arc(55, 55, 10, Math.PI, Math.PI * 1.5);
                ctx.fill();
                
                // Pipe connections
                ctx.fillRect(40, 0, 20, 10);
                ctx.fillRect(0, 40, 10, 20);
                
                return canvas.toDataURL();
            }

            createRightTopPipeImage() {
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#0984e3';
                // Vertical part
                ctx.fillRect(45, 0, 10, 55);
                // Horizontal part
                ctx.fillRect(45, 45, 55, 10);
                // Curve
                ctx.beginPath();
                ctx.arc(45, 55, 10, Math.PI * 1.5, 0);
                ctx.fill();
                
                // Pipe connections
                ctx.fillRect(40, 0, 20, 10);
                ctx.fillRect(90, 40, 10, 20);
                
                return canvas.toDataURL();
            }

            createLeftBottomPipeImage() {
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#0984e3';
                // Vertical part
                ctx.fillRect(45, 45, 10, 55);
                // Horizontal part
                ctx.fillRect(0, 45, 55, 10);
                // Curve
                ctx.beginPath();
                ctx.arc(55, 45, 10, Math.PI * 0.5, Math.PI);
                ctx.fill();
                
                // Pipe connections
                ctx.fillRect(40, 90, 20, 10);
                ctx.fillRect(0, 40, 10, 20);
                
                return canvas.toDataURL();
            }

            createRightBottomPipeImage() {
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#0984e3';
                // Vertical part
                ctx.fillRect(45, 45, 10, 55);
                // Horizontal part
                ctx.fillRect(45, 45, 55, 10);
                // Curve
                ctx.beginPath();
                ctx.arc(45, 45, 10, 0, Math.PI * 0.5);
                ctx.fill();
                
                // Pipe connections
                ctx.fillRect(40, 90, 20, 10);
                ctx.fillRect(90, 40, 10, 20);
                
                return canvas.toDataURL();
            }
        }

        // Initialize the game
        const game = new PlumbingGame();
    </script>
</body>
</html>